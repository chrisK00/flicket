// Unobtrusive validation support library for TanvirArjel.CustomValidation library
// Copyright (c) TanvirArjel. All rights reserved.
// Licensed under the MIT License, Version 2.0. See License.txt in the project root for license information.
// @version v1.0.1


!function (e) { e.validator.setDefaults({ onfocusout: function (e, t) { 9 === t.which && "" === this.elementValue(e) || this.element(e) } }); var t = function (e) { var t = e.split("-"), a = t[0], r = t[1]; return t[2] + "-" + (["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"].indexOf(r) + 1) + "-" + a }, a = function (e) { return 11 === e.length && (e = t(e)), "Invalid Date" !== new Date(e).toString() && !isNaN(new Date(e)) }, r = function (e) { if (a(e)) { if (/\d{4}-\d{2}-\d{2}/i.test(e)) { return -1 === e.indexOf("T") ? new Date(e + "T00:00:00") : new Date(e) } return 11 === e.length && (e = t(e)), new Date(e) } throw { name: "InvalidDateTimeFormat", message: "Input date/datetime is not in valid format. Please enter the date in valid datetime format. Prefer: '01-Jan-1999' format." } }; e.validator.addMethod("valid-date-format", function (e, r, n) { return !e || (11 === e.length && (date = t(e)), a(e)) }), e.validator.unobtrusive.adapters.add("valid-date-format", [], function (e) { e.rules["valid-date-format"] = {}, e.messages["valid-date-format"] = e.message }), e.validator.addMethod("mindate", function (e, t, a) { if (e) { const t = new Date(a.date); return r(e) >= t } return !0 }), e.validator.unobtrusive.adapters.add("mindate", ["date"], function (e) { e.rules.mindate = e.params, e.messages.mindate = e.message }), e.validator.addMethod("maxdate", function (e, t, a) { if (e) { const t = new Date(a.date); return r(e) <= t } return !0 }), e.validator.unobtrusive.adapters.add("maxdate", ["date"], function (e) { e.rules.maxdate = e.params, e.messages.maxdate = e.message }), e.validator.addMethod("currenttime", function (e, t, a) { if (e) { return new Date > r(e) } return !0 }), e.validator.unobtrusive.adapters.add("currenttime", [], function (e) { e.rules.currenttime = {}, e.messages.currenttime = e.message }), e.validator.addMethod("maxage", function (e, t, a) { if (e) { let t = new Date; return t.setFullYear(t.getFullYear() - a.years), t.setMonth(t.getMonth() - a.months), t.setDate(t.getDate() - a.days), r(e) >= t } return !0 }), e.validator.unobtrusive.adapters.add("maxage", ["years", "months", "days"], function (e) { e.rules.maxage = e.params, e.messages.maxage = e.message }), e.validator.addMethod("minage", function (e, t, a) { if (e) { let t = new Date; return t.setFullYear(t.getFullYear() - a.years), t.setMonth(t.getMonth() - a.months), t.setDate(t.getDate() - a.days), t >= r(e) } return !0 }), e.validator.unobtrusive.adapters.add("minage", ["years", "months", "days"], function (e) { e.rules.minage = e.params, e.messages.minage = e.message }), e.validator.addMethod("filetype", function (e, t, a) { var r = e.split(".").pop(); return -1 !== a.validtypes.toLowerCase().indexOf(r.toLowerCase()) }), e.validator.unobtrusive.adapters.add("filetype", ["validtypes"], function (e) { e.rules.filetype = e.params, e.messages.filetype = e.message }), e.validator.addMethod("file-minsize", function (e, t, a) { if (e && t.files[0]) { var r = a.value; return t.files[0].size / 1024 >= r } return !0 }), e.validator.unobtrusive.adapters.add("file-minsize", ["value"], function (e) { e.rules["file-minsize"] = e.params, e.messages["file-minsize"] = e.message }), e.validator.addMethod("file-maxsize", function (e, t, a) { if (e && t.files[0]) { var r = a.value; return t.files[0].size / 1024 <= r } return !0 }), e.validator.unobtrusive.adapters.add("file-maxsize", ["value"], function (e) { e.rules["file-maxsize"] = e.params, e.messages["file-maxsize"] = e.message }), e.validator.addMethod("input-type-compare", function (t, a, r) { var n = e(a).prop("type"), i = r.property; return n === e(a).closest("form").find('[name="' + i + '"]').prop("type") }), e.validator.unobtrusive.adapters.add("input-type-compare", ["property"], function (e) { e.rules["input-type-compare"] = e.params, e.messages["input-type-compare"] = e.message }), e.validator.addMethod("comparison-equal", function (t, n, i) { const o = t, s = e(n).prop("type"), d = i.property, u = e(n).closest("form").find('[name="' + d + '"]'), l = u.prop("type"), m = u.val(); if (o && m) { if ("number" === s && s === l) return Number(t) === Number(u.val()); if ("text" === s && s === l) { if (a(o) && a(m)) { const e = r(o), t = r(m); return e.getTime() === t.getTime() } return o.length === m.length } if (-1 !== s.indexOf("date") && -1 !== l.indexOf("date")) { const e = r(t), a = r(m); return e.getTime() === a.getTime() } if ("time" === s && s == l) return o === m } return !0 }), e.validator.unobtrusive.adapters.add("comparison-equal", ["property"], function (e) { e.rules["comparison-equal"] = e.params, e.messages["comparison-equal"] = e.message }), e.validator.addMethod("comparison-not-equal", function (t, n, i) { const o = t, s = e(n).prop("type"), d = i.property, u = e(n).closest("form").find('[name="' + d + '"]'), l = u.prop("type"), m = u.val(); if (o && m) { if ("number" === s && s === l) return Number(t) !== Number(u.val()); if ("text" === s && s === l) { if (a(o) && a(m)) { const e = r(o), t = r(m); return e.getTime() !== t.getTime() } return o.length !== m.length } if (-1 !== s.indexOf("date") && -1 !== l.indexOf("date")) { const e = r(t), a = r(m); return e.getTime() !== a.getTime() } if ("time" === s && s == l) return o !== m } return !0 }), e.validator.unobtrusive.adapters.add("comparison-not-equal", ["property"], function (e) { e.rules["comparison-not-equal"] = e.params, e.messages["comparison-not-equal"] = e.message }), e.validator.addMethod("comparison-greater-than", function (t, n, i) { const o = t; let s = e(n).prop("type"); const d = i.property, u = e(n).closest("form").find('[name="' + d + '"]'), l = u.prop("type"), m = u.val(); if (o && m) { if ("number" === s && s === l) return Number(o) > Number(m); if ("text" === s && s === l) { if (a(o) && a(m)) { return r(o) > r(m) } return o.length > m.length } if (-1 !== s.indexOf("date") && -1 !== l.indexOf("date")) { return r(t) > r(m) } if ("time" === s && s == l) return o > m } return !0 }), e.validator.unobtrusive.adapters.add("comparison-greater-than", ["property"], function (e) { e.rules["comparison-greater-than"] = e.params, e.messages["comparison-greater-than"] = e.message }), e.validator.addMethod("comparison-greater-than-or-equal", function (t, n, i) { const o = t; let s = e(n).prop("type"); const d = i.property, u = e(n).closest("form").find('[name="' + d + '"]'), l = u.prop("type"), m = u.val(); if (o && m) { if ("number" === s && s === l) return Number(o) >= Number(m); if ("text" === s && s === l) { if (a(o) && a(m)) { return r(o) >= r(m) } return o.length >= m.length } if (-1 !== s.indexOf("date") && -1 !== l.indexOf("date")) { return r(t) >= r(m) } if ("time" === s && s == l) return o >= m } return !0 }), e.validator.unobtrusive.adapters.add("comparison-greater-than-or-equal", ["property"], function (e) { e.rules["comparison-greater-than-or-equal"] = e.params, e.messages["comparison-greater-than-or-equal"] = e.message }), e.validator.addMethod("comparison-smaller-than", function (t, n, i) { const o = t, s = e(n).prop("type"), d = i.property, u = e(n).closest("form").find('[name="' + d + '"]'), l = u.prop("type"), m = u.val(); if (o && m) { if ("number" === s && s === l) return Number(o) < Number(m); if ("text" === s && s === l) { if (a(o) && a(m)) { return r(o) < r(m) } return o.length < m.length } if (-1 !== s.indexOf("date") && -1 !== l.indexOf("date")) { return r(t) < r(m) } if ("time" === s && s == l) return o < m } return !0 }), e.validator.unobtrusive.adapters.add("comparison-smaller-than", ["property"], function (e) { e.rules["comparison-smaller-than"] = e.params, e.messages["comparison-smaller-than"] = e.message }), e.validator.addMethod("comparison-smaller-than-or-equal", function (t, n, i) { const o = t, s = e(n).prop("type"), d = i.property, u = e(n).closest("form").find('[name="' + d + '"]'), l = u.prop("type"), m = u.val(); if (o && m) { if ("number" === s && s === l) return Number(o) <= Number(m); if ("text" === s && s === l) { if (a(o) && a(m)) { return r(o) <= r(m) } return o.length <= m.length } if (-1 !== s.indexOf("date") && -1 !== l.indexOf("date")) { return r(t) <= r(m) } if ("time" === s && s == l) return o <= m } return !0 }), e.validator.unobtrusive.adapters.add("comparison-smaller-than-or-equal", ["property"], function (e) { e.rules["comparison-smaller-than-or-equal"] = e.params, e.messages["comparison-smaller-than-or-equal"] = e.message }), e.validator.addMethod("texteditor-required", function (t, a, r) { const n = jQuery(e("<p>").html(t)).text().replace(/\s\s+/g, " "); return " " !== n && n.length > 0 }), e.validator.unobtrusive.adapters.add("texteditor-required", [], function (e) { e.rules["texteditor-required"] = e.params, e.messages["texteditor-required"] = e.message }), e.validator.addMethod("texteditor-minlength", function (t, a, r) { const n = jQuery(e("<p>").html(t)).text().replace(/\s\s+/g, " "), i = r.value; return " " !== n && n.length >= i }), e.validator.unobtrusive.adapters.add("texteditor-minlength", ["value"], function (e) { e.rules["texteditor-minlength"] = e.params, e.messages["texteditor-minlength"] = e.message }), e.validator.addMethod("texteditor-maxlength", function (t, a, r) { const n = jQuery(e("<p>").html(t)).text().replace(/\s\s+/g, " "), i = r.value; return " " !== n && n.length <= i }), e.validator.unobtrusive.adapters.add("texteditor-maxlength", ["value"], function (e) { e.rules["texteditor-maxlength"] = e.params, e.messages["texteditor-maxlength"] = e.message }), e.validator.addMethod("fixed-length", function (t, a, r) { const n = jQuery(e("<p>").html(t)).text().replace(/\s\s+/g, " "), i = r.value; return !n || n.length == i }), e.validator.unobtrusive.adapters.add("fixed-length", ["value"], function (e) { e.rules["fixed-length"] = e.params, e.messages["fixed-length"] = e.message }), e.validator.addMethod("requiredif", function (t, a, n) { const i = n["other-property"], o = n["comparison-type"], s = n["other-property-type"]; let d = n["other-property-value"]; const u = e(a).closest("form").find('[name="' + i + '"]'), l = u.attr("type"); let m = null; "checkbox" == l || "radio" == l ? m = e("[name$='" + i + "']:checked").val() : m = u.val(); if ("number" == s) d = Number(d), m = Number(m); else if ("datetime" == s) d && (d = r(d), "Equal" != o && "NotEqual" != o || (d = d.getTime())), m && (m = r(m), "Equal" != o && "NotEqual" != o || (m = m.getTime())); else if ("string" == s) "Equal" == o || "NotEqual" == o ? (d = d, m = m) : (m = m.length, d = d.length); else { if ("timespan" != s) throw { name: "InvalidTypeException", message: "The type in not supported in requiredif validation." }; d = d, m = m } if ("Equal" == o) { if (m == d) return !!t } else if ("NotEqual" == o) { if (m != d) return !!t } else if ("GreaterThan" == o) { if (m > d) return !!t } else if ("GreaterThanOrEqual" == o) { if (m >= d) return !!t } else if ("SmallerThan" == o) { if (m < d) return !!t } else if ("SmallerThanOrEqual" == o && m <= d) return !!t; return !0 }), e.validator.unobtrusive.adapters.add("requiredif", ["other-property", "comparison-type", "other-property-type", "other-property-value"], function (e) { e.rules.requiredif = e.params, e.messages.requiredif = e.message }) }(jQuery);